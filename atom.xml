<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VicoV的博客</title>
  
  <subtitle>无风自动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangkn.com/"/>
  <updated>2018-10-08T06:28:29.687Z</updated>
  <id>http://wangkn.com/</id>
  
  <author>
    <name>wangkun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>隐私政策</title>
    <link href="http://wangkn.com/2018/10/08/iosPrivacyPolicy/"/>
    <id>http://wangkn.com/2018/10/08/iosPrivacyPolicy/</id>
    <published>2018-10-08T06:16:00.000Z</published>
    <updated>2018-10-08T06:28:29.687Z</updated>
    
    <content type="html"><![CDATA[<p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><a id="more"></a><h4 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1. 适用范围"></a>1. 适用范围</h4><p>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；</p><p>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p><p>(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。</p><p>您了解并同意，以下信息不适用本隐私权政策：</p><p>(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；</p><p>(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；</p><p>(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p><h4 id="2-信息使用"><a href="#2-信息使用" class="headerlink" title="2. 信息使用"></a>2. 信息使用</h4><p>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。</p><p>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。</p><p>(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。</p><h4 id="3-信息披露"><a href="#3-信息披露" class="headerlink" title="3. 信息披露"></a>3. 信息披露</h4><p>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：</p><p>(a) 经您事先同意，向第三方披露；</p><p>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；</p><p>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；</p><p>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；</p><p>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。</p><p>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p><h4 id="4-信息存储和交换"><a href="#4-信息存储和交换" class="headerlink" title="4. 信息存储和交换"></a>4. 信息存储和交换</h4><p>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p><h4 id="5-Cookie的使用"><a href="#5-Cookie的使用" class="headerlink" title="5. Cookie的使用"></a>5. Cookie的使用</h4><p>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。</p><p>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。</p><p>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p><h4 id="6-信息安全"><a href="#6-信息安全" class="headerlink" title="6. 信息安全"></a>6. 信息安全</h4><p>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。</p><p>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对</p><h4 id="7-本隐私政策的更改"><a href="#7-本隐私政策的更改" class="headerlink" title="7.本隐私政策的更改"></a>7.本隐私政策的更改</h4><p>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。</p><p>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p><p>方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wangkn.com/categories/iOS/"/>
    
    
      <category term="iOS隐私政策" scheme="http://wangkn.com/tags/iOS%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
    
  </entry>
  
  <entry>
    <title>Xcode关闭烦人的警告</title>
    <link href="http://wangkn.com/2016/10/14/Xcode%E5%85%B3%E9%97%AD%E7%83%A6%E4%BA%BA%E7%9A%84%E8%AD%A6%E5%91%8A/"/>
    <id>http://wangkn.com/2016/10/14/Xcode关闭烦人的警告/</id>
    <published>2016-10-14T03:11:05.000Z</published>
    <updated>2018-09-14T01:41:21.205Z</updated>
    
    <content type="html"><![CDATA[<p>每次在使用performSelector：方法的时候系统都会给个警告，如下图<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014102418177.jpg"></p><h2 id="那么如何关闭这样的警告呢？"><a href="#那么如何关闭这样的警告呢？" class="headerlink" title="那么如何关闭这样的警告呢？"></a>那么如何关闭这样的警告呢？</h2><p>很简单，只需要添加以下代码即可让警告消失</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">//code这里插入相关的代码</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure><a id="more"></a><p>“-Warc-performSelector-leaks” 是警告类型。<br><em>#pragma clang diagnostic ignored</em>后面只能跟一个忽略警告类型。<br>如果需要同时忽略多种警告（如下图）<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014103131307.jpg"></p><p>只需要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wint-conversion&quot;</span><br><span class="line">            NSInteger type = [aspectInfo.instance performSelector:NSSelectorFromString(@&quot;searchType&quot;)];</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure></p><h2 id="那么问题又来了，我怎么知道警告是什么类型的呢？"><a href="#那么问题又来了，我怎么知道警告是什么类型的呢？" class="headerlink" title="那么问题又来了，我怎么知道警告是什么类型的呢？"></a>那么问题又来了，我怎么知道警告是什么类型的呢？</h2><p>其实这些警告不需要我们记忆，Xcode会告诉我们。<br>如何让Xcode告诉我们呢？<br>首先我们右击警告标识，会出现Reveal in Issue Navigator，如下图<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014104105107.jpg"></p><p>点击这个Reveal in Issue Navigator，Xcode会在Issue Navigator定位到你当前选中的issue。然后我们右击在Issue Navigator里定位到的那一条警告，右击，会出现Reveal in Log，如下图<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014104608765.jpg"></p><p>我们选中这个Reveal in Log点击，则会显示<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014110800152.jpg"></p><p>喜大普奔~~~~</p><hr><p>然而，有时候你会发现：<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014165344240.jpg"></p><p>看到这个442个⚠️，此时此刻<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014164236264.jpg">       </p><h2 id="那么我们该如何简单快捷的关闭大量的警告呢？"><a href="#那么我们该如何简单快捷的关闭大量的警告呢？" class="headerlink" title="那么我们该如何简单快捷的关闭大量的警告呢？"></a>那么我们该如何简单快捷的关闭大量的警告呢？</h2><p> 1、 我们可以关闭某一个指定文件的某种指定类型的警告。<br> 我们拿具体项目来说，如下图每个地方报了3个警告：<br> <img src="http://img.blog.csdn.net/20161014170511778" alt="这里写图片描述"></p><p>其实关闭某个指定文件的某种类型的警告很简单,就如同我们以前给某一个文件添加 ARC支持或者不支持的时候那样 添加 忽略/显示 某种类型警告。像这样：<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014170924356.jpg"> </p><p>添加完成再编译，原来-Wint-conversion类型的警告就没有了，如下图<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014171237966.jpg"> </p><p>ps：警告类型是  “-Wint-conversion”，那么忽略就是 “-Wno-int-conversion”</p><p>2、我们可以让编译器忽略整个工程某种指定类型的警告。<br>工程target –&gt; Build Settings –&gt; Other Warning Flags，如下图<br><img src="/2016/10/14/Xcode关闭烦人的警告/20161014172703419.jpg"></p><p>添加完成后编译，整个target的指定类型的警告就没了。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次在使用performSelector：方法的时候系统都会给个警告，如下图&lt;br&gt;&lt;img src=&quot;/2016/10/14/Xcode关闭烦人的警告/20161014102418177.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;那么如何关闭这样的警告呢？&quot;&gt;&lt;a href=&quot;#那么如何关闭这样的警告呢？&quot; class=&quot;headerlink&quot; title=&quot;那么如何关闭这样的警告呢？&quot;&gt;&lt;/a&gt;那么如何关闭这样的警告呢？&lt;/h2&gt;&lt;p&gt;很简单，只需要添加以下代码即可让警告消失&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//code这里插入相关的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wangkn.com/categories/iOS/"/>
    
    
      <category term="Xcode" scheme="http://wangkn.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods入门 --小白篇</title>
    <link href="http://wangkn.com/2015/12/15/CocoaPods%E5%85%A5%E9%97%A8-%E5%B0%8F%E7%99%BD%E7%AF%87/"/>
    <id>http://wangkn.com/2015/12/15/CocoaPods入门-小白篇/</id>
    <published>2015-12-14T16:19:23.000Z</published>
    <updated>2018-09-14T01:30:37.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CocoaPods是什么？"><a href="#1-CocoaPods是什么？" class="headerlink" title="1.CocoaPods是什么？"></a>1.CocoaPods是什么？</h2><p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。<br><a id="more"></a></p><p>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。</p><hr><h2 id="2-如何下载和安装CocoaPods？"><a href="#2-如何下载和安装CocoaPods？" class="headerlink" title="2.如何下载和安装CocoaPods？"></a>2.如何下载和安装CocoaPods？</h2><p>在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下。</p><p>假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>但是，且慢。如果你在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。<br>但是，是的，又但是（不过是个可喜的“但是”）。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">//等有反应之后再敲入以下命令</span><br><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br></pre></td></tr></table></figure><p>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure><p>只有在终端中出现下面文字才表明你上面的命令是成功的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">http://ruby.taobao.org/</span><br></pre></td></tr></table></figure><p>上面的命令完成之时，本人的终端上是这个的样子：<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151214234252266.jpg"><br>这时候，你再次在终端中运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。<br>看到这里，你心里会不会说，我靠！太爽了，这么容易就可以下载并且安装好了！是的，本人也是这么想的。CocoPods就是这么简单，使用也十分简单。继续往下看吧。</p><p>…………………………………………………………………………..<br>执行pod install 命令<br>出现Setting up CocoaPods master repo，说明Cocoapods在将它的信息下载到 ~/.cocoapods里；<br>cd  到该目录里，用du -sh *命令来查看文件大小，每隔几分钟查看一次，这个目录最终大小是100多M，就是完成了。<br>…………………………………………………………………………..</p><h2 id="3-如何使用CocoaPods？"><a href="#3-如何使用CocoaPods？" class="headerlink" title="3.如何使用CocoaPods？"></a>3.如何使用CocoaPods？</h2><p>安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。<br>本人在这里用两种使用场景来具体说明如何使用CocoaPods。</p><p><strong>场景1：利用CocoaPods，在项目中导入AFNetworking类库</strong></p><p>AFNetworking类库在GitHub地址是：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">https://github.com/AFNetworking/AFNetworking</a><br>为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search AFNetworking</span><br></pre></td></tr></table></figure><p>过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。比如:<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151214234835198.jpg"><br>这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。<br>首先，我们需要在我们的项目中加入CocoaPods的支持。</p><p>首先先用Xcode创建一个名字为CocoaPodsDemo的项目，用于以下教程。创建好之后先看看没有支持CocoaPods时的项目Xcode目录结构：<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151214235331235.jpg"><br>上图等一下要跟项目支持CocoaPods之后的项目Xcode目录结构做对比。<br>你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。<br>好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim Podfile</span><br></pre></td></tr></table></figure><p>然后在Podfile文件中输入以下文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;</span><br></pre></td></tr></table></figure><p>注意，这段文字不是本人凭空生成的，可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 8.0, 要下载的AFNetworking版本是3.0。<br>然后保存退出。vim环境下，保存退出命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。<br>这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure><p>因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。</p><p>运行上述命令之后，本人的终端出现以下信息：<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151215000519044.jpg"><br>注意下面绿色字体的一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。<br>你也许会郁闷，为什么会出现.xcodeproj文件呢。这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”。 点击 CocoaPodsDemo.xcworkspace 打开之后工程之后，项目Xcode目录结构如下图：<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151215000730388.jpg"><br>你会惊喜地发现，AFNetwoking已经成功导入项目了（红框部分）！<br>现在，你就可以开始使用AFNetworking.h啦。可以稍微测试一下，在你的项目任意代码文件中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AFNetworking.h&gt;</span><br><span class="line">或者</span><br><span class="line">#import &quot;AFNetworking.h&quot;</span><br></pre></td></tr></table></figure><p>然后编译，看看是否出错。如果你严格按照上述的步骤来，是不可能出错的啦。</p><p>至此，CocoPods的第一个应用场景讲述完毕。别看写了这么多，其实过程是十分简单的。总结一下就是：</p><ol><li>先在项目中创建Podfile，Podfile的内容是你想导入的类库。一般类库的原作者会告诉你导入该类库应该如何写Podfile；</li><li>运行命令：`$ pod install.</li></ol><p><strong>场景2：如何正确编译运行一个包含CocoPods类库的项目</strong><br>你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。<br>下面，以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。<br>UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods，如下图：<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151215001219414.png"><br>这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure><p>过几秒（也许需要十几秒，取决于你的网络状况）之后，终端出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `UAAppReviewManager` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing UAAppReviewManager (0.1.6)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] From now on use `UAAppReviewManagerExample.xcworkspace`.</span><br></pre></td></tr></table></figure><p>这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace：<br><img src="/2015/12/15/CocoaPods入门-小白篇/20151215001353620.png"><br>根据终端的信息提示，你以后就需用新产生的UAAppReviewManagerExample.xcworkspace来运行这个Example代码了。<br>注意，这里有个小问题，如果刚刚你不是输入$ pod update，而是输入$ pod install，会发现类库导入不成功，并且终端出现下面提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!] Required version (UAAppReviewManager (from `../`)) not found for `UAAppReviewManager`.</span><br><span class="line">Available versions: 0.1.6</span><br></pre></td></tr></table></figure><p>这里的意思大概是Podfile文件过期，类库有升级，但是Podfile没有更改。$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 $ pod update会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。</p><p>那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，我又不知道类库有没有新版本。好吧，那你每次直接用 $ pod update 算了。或者先用 $ pod install，如果不行，再用 $ pod update。</p><hr><p><strong>常见错误</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff: /../Podfile.lock: No such file or directory </span><br><span class="line">diff: Manifest.lock: No such file or directory </span><br><span class="line">error: The sandbox is not in sync with the Podfile.lock. Run &apos;pod install&apos; or update your CocoaPods installation.`</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong><br>关闭当前的工作空间，删除掉文件夹中的workspace，然后重新pod install，install完成之后，通过workspace打开工作空间，clean+build即可，如下所示：<br>先cd 到目标目录下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf MyProject.xcworkspace </span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><p>在pod install之前，请确保已经执行pod setup命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-CocoaPods是什么？&quot;&gt;&lt;a href=&quot;#1-CocoaPods是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.CocoaPods是什么？&quot;&gt;&lt;/a&gt;1.CocoaPods是什么？&lt;/h2&gt;&lt;p&gt;当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wangkn.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wangkn.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何实现3d-Touch</title>
    <link href="http://wangkn.com/2015/10/29/3d-Touch/"/>
    <id>http://wangkn.com/2015/10/29/3d-Touch/</id>
    <published>2015-10-29T08:19:05.000Z</published>
    <updated>2018-09-12T10:08:28.777Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前就想写一篇关于3D Touch的博客，因为各种原因一直到现在才开始写(其实就是懒&gt;_&lt;)。咳咳，趁着发呆时间赶紧来写一篇…<a href="https://github.com/VicoWang/3D-Touch" target="_blank" rel="noopener">demo请戳这里</a></p><a id="more"></a><hr><p>3D Touch分为以下三大模块：<br>1.Home Screen Quick Actions<br>2.Peek and Pop<br>3.UITouch</p><hr><h2 id="1-Home-Screen-Quick-Actions"><a href="#1-Home-Screen-Quick-Actions" class="headerlink" title="1. Home  Screen Quick Actions"></a>1. Home  Screen Quick Actions</h2><p>重按主界面应用图标后弹出的快捷菜单，例如重按微信会出现这样的效果。<br><img src="/2015/10/29/3d-Touch/20151029104541512.jpg"><br>实现Quick Actions分为两种：静态和动态。</p><h5 id="1-1-Static（静态）Quick-Actions"><a href="#1-1-Static（静态）Quick-Actions" class="headerlink" title="1.1 Static（静态）Quick Actions"></a>1.1 Static（静态）Quick Actions</h5><p>Static Quick Actions只需要我们在项目的info.plist文件中配置，在用户安装程序后就可以使用。<br>配置Static Quick Actions只需要在info.plist文件中添加如下键值。</p><p>1.1.1 必填项（下面两个键值是必须设置的）:<br>UIApplicationShortcutItemType 这个键值设置一个快捷通道类型的字符串<br>UIApplicationShortcutItemTitle   这个键值设置标签的标题<br>1.1.2 选填项（下面这些键值不是必须设置的）：<br>UIApplicationShortcutItemSubtitle    设置标签的副标题<br>UIApplicationShortcutItemIconType 设置标签Icon类型<br>UIApplicationShortcutItemIconFile   设置标签的Icon文件<br>UIApplicationShortcutItemUserInfo  设置信息字典(用于传值)<br><img src="/2015/10/29/3d-Touch/20151029110028849.jpg"><br>如图配置好info.plist文件之后，运行程序，真机上测试效果如下：<br><img src="/2015/10/29/3d-Touch/20151029110624536.jpg"></p><h5 id="1-2-Dynamic（动态）-Quick-Actions"><a href="#1-2-Dynamic（动态）-Quick-Actions" class="headerlink" title="1.2 Dynamic（动态） Quick Actions"></a>1.2 Dynamic（动态） Quick Actions</h5><p>Dynamic Quick Actions是我们在程序中通过代码添加，与之相关的类主要有3个：<br>UIApplicationShortcutItem 创建3DTouch action的类<br>UIMutableApplicationShortcutItem 创建可变的3DTouch action的类<br>UIApplicationShortcutIcon 创建标签中图片icon的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIApplicationShortcutIcon *icon1 = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeInvitation];</span><br><span class="line">UIMutableApplicationShortcutItem *item1 = [[UIMutableApplicationShortcutItem alloc]initWithType:@&quot;1&quot; localizedTitle:@&quot;么么哒&quot;];</span><br><span class="line">item1.icon = icon1;</span><br><span class="line"></span><br><span class="line">UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeContact];</span><br><span class="line">UIApplicationShortcutItem *item2 = [[UIApplicationShortcutItem alloc]initWithType:@&quot;2&quot; localizedTitle:@&quot;萌萌哒&quot; localizedSubtitle:@&quot;看这里是不是想到了tableView&quot; icon:icon2 userInfo:nil</span><br><span class="line">];</span><br><span class="line">application.shortcutItems = @[item1,item2];</span><br></pre></td></tr></table></figure><p>我在application:didFinishLaunchingWithOptions:方法里面添加了以上代码，运行程序，真机测试的效果如下:<br><img src="/2015/10/29/3d-Touch/20151029112319649.jpg"><br>上述代码里面设置的icon不是UIImage，而是一个叫UIApplicationShortcutIcon的类。<br><img src="/2015/10/29/3d-Touch/20151029112659823.jpg"><br>API很简单吧~值得注意的是官方API里面的这句话：</p><blockquote><p>Icons should be square, single color, and 35x35 points, as shown in these template files and as described in Template Images in UIKit User Interface Catalog and in iOS Human Interface Guidelines.</p></blockquote><h5 id="1-3-Actions-被点击后的响应"><a href="#1-3-Actions-被点击后的响应" class="headerlink" title="1.3 Actions 被点击后的响应"></a>1.3 Actions 被点击后的响应</h5><p>类似推送，当我们点击Actions进入应用程序时，也可以进行一些操作，我们可以发现，在application中增加了这样一个方法：<br><img src="/2015/10/29/3d-Touch/20151029113210112.jpg"><br>当我们通过点击Actions进入app时，就会在appdelegate中调用这样一个回调，我们可以获取shortcutItem的信息进行相关逻辑操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">if ([shortcutItem.localizedTitle isEqualToString:@&quot;New Message&quot;])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">UIAlertController *alertC = [UIAlertController alertControllerWithTitle:@&quot;老板&quot; message:@&quot;过来办公室，发妹子了&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;马上就来&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">[alertC dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;];</span><br><span class="line">[alertC addAction:action];</span><br><span class="line">[self.window.rootViewController presentViewController:alertC animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else if ([shortcutItem.localizedTitle isEqualToString:@&quot;Favorites&quot;])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">UINavigationController *naVC = (UINavigationController *)self.window.rootViewController;</span><br><span class="line">[naVC popToRootViewControllerAnimated:NO];</span><br><span class="line">ThirdViewController *thirdVC = [[ThirdViewController alloc]init];</span><br><span class="line">[naVC pushViewController:thirdVC animated:YES];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在application: performActionForShortcutItem: completionHandler:方法里面写了这样一段代码，然后通过点击外界的New Message Action进入APP，就会走第一个if里面的语句，点击外界的Favorites Action进入APP，就会走第二个if里面的语句。真机测试效果如下:<br><img src="/2015/10/29/3d-Touch/20151029140226239.gif"></p><p>这里有一点需要注意：我们在app的入口函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;</span><br></pre></td></tr></table></figure></p><p>需要进行一下判断，在luanchOptions中有个UIApplicationLaunchOptionsShortcutItemKey这样一个键，通过它，我们可以区别是否是从标签进入的APP，如果是则处理结束逻辑后，返回NO，防止处理逻辑被反复回调。</p><hr><h2 id="2-Peek-and-Pop"><a href="#2-Peek-and-Pop" class="headerlink" title="2. Peek and Pop"></a>2. Peek and Pop</h2><p>Peek and Pop实际上就是基于重按的两个操作：peek 和pop。使用场景是item的详细信息不能完全展示出来时，通过3D Touch来预览以及跳转至详情页。苹果在这方面的封装很严实，我们不能修改动画的样式，只能修改preview(预览)窗的高度。什么？不知道具体的效果？好吧，先带你们看一下Peek and Pop的效果。<br><img src="/2015/10/29/3d-Touch/20151029141318865.gif"></p><p>2.1 Peek<br>在第一次重按item时触发的操作，会弹出预览框。弹出预览框后，如果这时松手，那么预览框也会随即消失。<br>2.2 Pop<br>Peek操作完成后不松手，再次重按，就可以跳转至详情页了。在跳转至详情页的过程中，我们还可以看到一个轻微的纵向弹性动画。</p><p>看完了Peek and Pop 我们就来简单的实现一下吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//首先接受代理</span><br><span class="line">@interface ForthTableViewController () &lt;UIViewControllerPreviewingDelegate&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//然后在viewDidLoad里面注册一下registerForPreviewingWithDelegate:sourceView:</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">//判断是否支持3D Touch，如果支持则需要注册一下</span><br><span class="line">if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) &#123;</span><br><span class="line">[self registerForPreviewingWithDelegate:self sourceView:self.view];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//实现代理方法</span><br><span class="line">//Peek手势触发，进入预览界面</span><br><span class="line">- (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location</span><br><span class="line">&#123;</span><br><span class="line">NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location];</span><br><span class="line">UITableViewCell *cell  = [self.tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">previewingContext.sourceRect = cell.frame;</span><br><span class="line">ThirdViewController *childVC = [[ThirdViewController alloc] init];</span><br><span class="line">UILabel *label      = [[UILabel alloc]init];</span><br><span class="line">label.text          = cell.textLabel.text;</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label.textColor     = [UIColor redColor];</span><br><span class="line">childVC.view        = label;</span><br><span class="line">childVC.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">childVC.preferredContentSize = CGSizeMake(0.0f,400.0f);</span><br><span class="line"></span><br><span class="line">return childVC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Pop手势触发，进入详情界面</span><br><span class="line">- (void)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit</span><br><span class="line">&#123;</span><br><span class="line">[self showViewController:viewControllerToCommit sender:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写到这里，真机运行一下看看效果：<br><img src="/2015/10/29/3d-Touch/20151029155243726.gif"><br>效果看起来还不错~~^_^</p><p>接下来我们想起来还有个家伙叫UIPreviewAction，它是Peek预览时上滑底部会出现的菜单。那么该如何添加预览时上滑底部的菜单呢？<br>只需要在我们创建的预览控制器(就是上方的ThirdViewController *childVC)里面重写一下如下这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray &lt;id &lt;UIPreviewActionItem&gt;&gt; *)previewActionItems &#123;</span><br><span class="line">UIPreviewAction *p1 = [UIPreviewAction actionWithTitle:@&quot;点我!&quot;style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;点击了点我!&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">UIPreviewAction *p2 = [UIPreviewAction actionWithTitle:@&quot;别点我!&quot; style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;点击了别点我!&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">NSArray *actions = @[p1,p2];</span><br><span class="line">return actions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我写的代码如上所示，然后直接真机跑起来看看效果：<br><img src="/2015/10/29/3d-Touch/20151029160817411.gif"></p><hr><h2 id="3-UITouch"><a href="#3-UITouch" class="headerlink" title="3. UITouch"></a>3. UITouch</h2><p>UITouch里面多了两个API，分别是力度和最大力度。这个就可以很个性化地做一些酷炫的交互操作了！没啥好说的，touch.force和touch.maximumPossibleForce。大家可以在官方API里面很容易找到他们。看一下就哦了。<br><img src="/2015/10/29/3d-Touch/20151029161500146.jpg"></p><hr><blockquote><p>结束语：刚开始写博客，如有疏漏或者错误之处，欢迎留言指正。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前就想写一篇关于3D Touch的博客，因为各种原因一直到现在才开始写(其实就是懒&amp;gt;_&amp;lt;)。咳咳，趁着发呆时间赶紧来写一篇…&lt;a href=&quot;https://github.com/VicoWang/3D-Touch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo请戳这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wangkn.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wangkn.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 打包静态库.a文件--入门</title>
    <link href="http://wangkn.com/2015/10/28/iOS-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93-a%E6%96%87%E4%BB%B6-%E5%85%A5%E9%97%A8/"/>
    <id>http://wangkn.com/2015/10/28/iOS-打包静态库-a文件-入门/</id>
    <published>2015-10-27T17:17:24.000Z</published>
    <updated>2018-09-12T10:07:37.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-制作-a"><a href="#1-制作-a" class="headerlink" title="1. 制作.a"></a>1. 制作.a</h2><h5 id="1-1新建项目-–-gt-Cocoa-Touch-Static-Library"><a href="#1-1新建项目-–-gt-Cocoa-Touch-Static-Library" class="headerlink" title="1.1新建项目 –&gt; Cocoa Touch Static Library"></a>1.1新建项目 –&gt; Cocoa Touch Static Library</h5><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027175143355.jpg"><a id="more"></a><h5 id="1-2添加库需要包含的代码"><a href="#1-2添加库需要包含的代码" class="headerlink" title="1.2添加库需要包含的代码"></a>1.2添加库需要包含的代码</h5><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027180022010.jpg"><h5 id="1-3将需要暴露的-h文件暴露出来，-m会自动编译到-a文件中"><a href="#1-3将需要暴露的-h文件暴露出来，-m会自动编译到-a文件中" class="headerlink" title="1.3将需要暴露的.h文件暴露出来，.m会自动编译到.a文件中"></a>1.3将需要暴露的.h文件暴露出来，.m会自动编译到.a文件中</h5><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027180717632.jpg"><h5 id="1-4分别选择真机设备和模拟器，command-B编译，staticTest会从红色变成黑色。真机和模拟器环境下用的-a文件是分开的。"><a href="#1-4分别选择真机设备和模拟器，command-B编译，staticTest会从红色变成黑色。真机和模拟器环境下用的-a文件是分开的。" class="headerlink" title="1.4分别选择真机设备和模拟器，command + B编译，staticTest会从红色变成黑色。真机和模拟器环境下用的.a文件是分开的。"></a>1.4分别选择真机设备和模拟器，command + B编译，staticTest会从红色变成黑色。真机和模拟器环境下用的.a文件是分开的。</h5><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027181505547.jpg"><h5 id="1-5在“Show-in-Finder-”，可以看到编译生成的-a-和-暴露的-h文件。"><a href="#1-5在“Show-in-Finder-”，可以看到编译生成的-a-和-暴露的-h文件。" class="headerlink" title="1.5在“Show in Finder ”，可以看到编译生成的.a 和 暴露的.h文件。"></a>1.5在“Show in Finder ”，可以看到编译生成的.a 和 暴露的.h文件。</h5><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027203351733.jpg"><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027203433752.jpg"><hr><p>Note：</p><ul><li>Debug-iphoneos 文件夹里面的东西是用在真机上的</li><li>Debug-iphonesimulator 文件夹里面的东西是用在模拟器上的</li><li>如果 Scheme 是 Release 模式，生成的文件夹就以 Release 开头<br><strong>调试版本 VS 发布版本</strong><ul><li>调试版本会包含完整的符号信息，以方便调试</li><li>调试版本不会对代码进行优化</li><li>发布版本不会包含完整的符号信息</li><li>发布版本的执行代码是进行过优化的</li><li>发布版本的大小会比调试版本的略小</li><li>在执行速度方面，发布版本会更快些，但不意味着会有显著的提升</li></ul></li></ul><hr><p>当我们需要打包的.a文件里面用到了图片等资源文件。此时我们不该直接把resource文件夹拖进项目，而是建立.bundle文件，然后把图片等资源放进.bundle里面管理。<br><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027230138887.jpg"><br><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151027230723090.jpg"><br>在其他项目中使用我们打包的.a文件时，只需要将.a文件和暴露的.h文件以及资源文件.bundle（有Xib时还需要拖Xib）拖进新项目即可使用。</p><hr><ol><li>如果想要使打包好的.a文件能同时在模拟器和真机上使用，需要将两个.a文件进行合并。在终端输入指令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create ~/Debug-iphoneos/libstaticTest.a ~/Debug-iphonesimulator/libstaticTest.a -output ~/libstaticTest.a</span><br></pre></td></tr></table></figure><p>即： lipo -create + 真机.a文件路径 + 模拟器.a文件路径 + -output + 合成.a文件的路径<br>PS：可以通过 lipo -info .a文件路径  指令查看.a的类型</p><hr><h2 id="2-调试-a"><a href="#2-调试-a" class="headerlink" title="2. 调试.a"></a>2. 调试.a</h2><h4 id="2-1创建一个application工程，可以正常运行。"><a href="#2-1创建一个application工程，可以正常运行。" class="headerlink" title="2.1创建一个application工程，可以正常运行。"></a>2.1创建一个application工程，可以正常运行。</h4><p> <img src="http://img.blog.csdn.net/20151028010607783" alt="这里写图片描述"></p><h4 id="2-2此时我们需要在这个工程里添加静态库进行调试，点击targets下面的-号，添加libriary"><a href="#2-2此时我们需要在这个工程里添加静态库进行调试，点击targets下面的-号，添加libriary" class="headerlink" title="2.2此时我们需要在这个工程里添加静态库进行调试，点击targets下面的+号，添加libriary"></a>2.2此时我们需要在这个工程里添加静态库进行调试，点击targets下面的+号，添加libriary</h4><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151028010855293.jpg"><h4 id="2-3此时在工程里面会出现静态库的文件夹，在此文件夹下面添加需要打包静态库的代码即可。"><a href="#2-3此时在工程里面会出现静态库的文件夹，在此文件夹下面添加需要打包静态库的代码即可。" class="headerlink" title="2.3此时在工程里面会出现静态库的文件夹，在此文件夹下面添加需要打包静态库的代码即可。"></a>2.3此时在工程里面会出现静态库的文件夹，在此文件夹下面添加需要打包静态库的代码即可。</h4><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151028011147100.jpg"><h4 id="2-4使用静态库，只需要将需要暴露的头文件引入project的类里。同时需要配置targets-gt-build-Phases-下的Target-Dependencies-和Link-Binary-With-Libraries-添加我们创建的静态库-a。"><a href="#2-4使用静态库，只需要将需要暴露的头文件引入project的类里。同时需要配置targets-gt-build-Phases-下的Target-Dependencies-和Link-Binary-With-Libraries-添加我们创建的静态库-a。" class="headerlink" title="2.4使用静态库，只需要将需要暴露的头文件引入project的类里。同时需要配置targets -&gt; build Phases 下的Target Dependencies 和Link Binary With Libraries 添加我们创建的静态库.a。"></a>2.4使用静态库，只需要将需要暴露的头文件引入project的类里。同时需要配置targets -&gt; build Phases 下的Target Dependencies 和Link Binary With Libraries 添加我们创建的静态库.a。</h4><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151028012451756.jpg"><h4 id="2-5打包静态库只需要选中静态库编译即可。具体打包方法同上。"><a href="#2-5打包静态库只需要选中静态库编译即可。具体打包方法同上。" class="headerlink" title="2.5打包静态库只需要选中静态库编译即可。具体打包方法同上。"></a>2.5打包静态库只需要选中静态库编译即可。具体打包方法同上。</h4><img src="/2015/10/28/iOS-打包静态库-a文件-入门/20151028011452509.jpg">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-制作-a&quot;&gt;&lt;a href=&quot;#1-制作-a&quot; class=&quot;headerlink&quot; title=&quot;1. 制作.a&quot;&gt;&lt;/a&gt;1. 制作.a&lt;/h2&gt;&lt;h5 id=&quot;1-1新建项目-–-gt-Cocoa-Touch-Static-Library&quot;&gt;&lt;a href=&quot;#1-1新建项目-–-gt-Cocoa-Touch-Static-Library&quot; class=&quot;headerlink&quot; title=&quot;1.1新建项目 –&amp;gt; Cocoa Touch Static Library&quot;&gt;&lt;/a&gt;1.1新建项目 –&amp;gt; Cocoa Touch Static Library&lt;/h5&gt;&lt;img src=&quot;/2015/10/28/iOS-打包静态库-a文件-入门/20151027175143355.jpg&quot;&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wangkn.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wangkn.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于升级Xcode版本后插件不能用的问题解决</title>
    <link href="http://wangkn.com/2015/08/10/%E5%85%B3%E4%BA%8E%E5%8D%87%E7%BA%A7Xcode%E7%89%88%E6%9C%AC%E5%90%8E%E6%8F%92%E4%BB%B6%E4%B8%8D%E8%83%BD%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://wangkn.com/2015/08/10/关于升级Xcode版本后插件不能用的问题解决/</id>
    <published>2015-08-10T08:05:25.000Z</published>
    <updated>2018-09-12T09:54:19.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近刚升级了Xcode6.4，然后就悲剧的发现以前装的插件都失效了。那么问题就来了，我们该怎么做才能让插件恢复正常呢。</p></blockquote><a id="more"></a><hr><h2 id="1-问题原因"><a href="#1-问题原因" class="headerlink" title="1. 问题原因"></a>1. 问题原因</h2><p>Xcode的插件放在目录：~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/ 下，为.xcplugin格式。通过右键Show  Content(显示包内容) 可以看到 xcplugin中存在一个info.plist。打开plist文件，会发现里面有一项为<strong>DVTPlugInCompatibilityUUIDs</strong>，我们姑且暂时猜测DVTPlugInCompatibilityUUIDs的作用：<strong>插件通过DVTPlugInCompatibilityUUIDs来指定能够运行此插件的Xcode版本。</strong>因此，DVTPlugInCompatibilityUUIDs中存放的是Xcode版本对应的UUID。Xcode在启动加载控件时，当前版本的UUID和插件中info.plist文件中DVTPlugInCompatibilityUUIDs存放的UUID数组进行匹配。匹配不到的话，则此插件无法在该版本Xcode上运行，插件也就失效了。</p><hr><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p>解决办法当然就是将Xcode当前版本的UUID加到插件的info.plist中的DVTPlugInCompatibilityUUIDs中即可。</p><blockquote><p>打开终端输入以下代码获取到DVTPlugInCompatibilityUUID：defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID<br><img src="/2015/08/10/关于升级Xcode版本后插件不能用的问题解决/20150810152542963.jpg"></p></blockquote><p>那么问题又来了。插件可能会有很多个，一个一个打开修改非常无聊与低效，此时就要用到命令行，让重复劳动自动化。</p><ul><li>获取到Xcode当前版本的UUID，然后在终端输入如下命令即可：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add 7FDF5C7A-131F-4ABB-9EDC-8C5F8F0B8A90</span><br></pre></td></tr></table></figure></li></ul><p>将两步合并成一步就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID`</span><br></pre></td></tr></table></figure><hr><p>做完上述步骤，重启Xcode试试。问题在此处应该得以解决，但是也会有依旧失效的现象。此时，我们再打开终端，运行以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-6.4</span><br></pre></td></tr></table></figure><p>重启Xcode，选择Load Bundles。OK。<br>仍旧有问题的童鞋，可以在插件Info.plist的DVTPlugInCompatibilityUUIDs中看看是否存在新增的UUID。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近刚升级了Xcode6.4，然后就悲剧的发现以前装的插件都失效了。那么问题就来了，我们该怎么做才能让插件恢复正常呢。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wangkn.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wangkn.com/tags/iOS/"/>
    
  </entry>
  
</feed>
